import inspect
import ast
from typing import Callable, Dict, Any

class MLVulnerabilityPredictor:
    """Simple ML predictor."""

    def __init__(self, config: Dict[str, Any] = None):
        if config is None:
            config = {}

        self.weights = config.get('weights', {
            'complexity': 0.3,
            'loops': 0.2,
            'dangerous_calls': 0.5,
            'cyclomatic_complexity': 0.4,
        })
        self.history = []

    def _extract_ast_features(self, func: Callable) -> Dict[str, float]:
        """Extracts features from a function's AST."""
        features = {
            'dangerous_calls': 0,
            'cyclomatic_complexity': 1,  # Start with a base complexity of 1
        }
        dangerous_functions = {'exec', 'eval', 'os.system', 'subprocess.run'}

        try:
            source = inspect.getsource(func)
            tree = ast.parse(source)

            for node in ast.walk(tree):
                # Calculate cyclomatic complexity
                if isinstance(node, (ast.If, ast.For, ast.While, ast.And, ast.Or, ast.ExceptHandler, ast.With)):
                    features['cyclomatic_complexity'] += 1

                # Count dangerous function calls
                if isinstance(node, ast.Call):
                    if isinstance(node.func, ast.Name) and node.func.id in dangerous_functions:
                        features['dangerous_calls'] += 1
                    elif isinstance(node.func, ast.Attribute):
                        # Handle calls like os.system
                        if isinstance(node.func.value, ast.Name) and node.func.value.id in {'os', 'subprocess'} and node.func.attr in dangerous_functions:
                            features['dangerous_calls'] += 1

        except (TypeError, OSError):
            # Fallback for built-in functions or functions defined in the REPL
            pass

        return features

    def extract_features(self, func: Callable) -> Dict[str, float]:
        try:
            source = inspect.getsource(func)
            legacy_features = {'complexity': len(source) / 1000, 'loops': source.count('for') + source.count('while')}
            ast_features = self._extract_ast_features(func)

            # Combine legacy and AST features
            combined_features = {**legacy_features, **ast_features}

            return {k: min(v, 1.0) for k, v in combined_features.items()}
        except:
            return {'complexity': 0.0, 'loops': 0.0, 'dangerous_calls': 0.0, 'cyclomatic_complexity': 0.0}

    def predict_score(self, features: Dict[str, float]) -> float:
        score = sum(features.get(k, 0) * w for k, w in self.weights.items())
        # Normalize the score to be between 0 and 1
        return 1.0 / (1.0 + 2.718 ** (-2 * score)) if score > 0 else 0.0

    def train(self, features: Dict, actual_vulns: int):
        predicted = self.predict_score(features)
        actual = min(actual_vulns / 5.0, 1.0)
        self.history.append({'error': abs(actual - predicted)})

    def get_accuracy(self) -> float:
        if not self.history:
            return 0.0
        return max(0.0, 1.0 - sum(h['error'] for h in self.history) / len(self.history))
